# -*- coding: utf-8 -*-
"""K-Mean và KNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K8PTsoxRrkizPK7TwXvp1-E5W5UgpfGQ
"""

import numpy as np # thư viện tính toán toán học
import matplotlib.pyplot as plt # visualize data sử dụng đồ thị
from scipy.spatial.distance import cdist # Hỗ trợ tính khoảng cách
# Khởi tạo 500 điểm dữ liệu xung quanh 3 tâm cụm (2, 2), (9, 2) và (4,9).
means = [[2, 2], [9, 2], [4, 9]]
cov = [[2, 0], [0, 2]]
n_samples = 500
n_cluster = 3
X0 = np.random.multivariate_normal(means[0], cov, n_samples)
X1 = np.random.multivariate_normal(means[1], cov, n_samples)
X2 = np.random.multivariate_normal(means[2], cov, n_samples)
X = np.concatenate((X0, X1, X2), axis = 0)
# Xem phân bố của dữ liệu mà chúng ta vừa tạo ra.
plt.xlabel('x')
plt.ylabel('y')
plt.plot(X[:, 0], X[:, 1], 'bo', markersize=5)
plt.plot()
plt.show()

# Sử dụng kĩ thuật k-means để tìm tâm của 3 cụm từ dữ liệu vừa tạo ở bước 2.

# Viết hàm khởi tạo n_cluster=3 tâm cụm.
def kmeans_init_centers(X, n_cluster):
## random k index beetween 0 and shape(X) without duplicate index.
## Then return X[index] as cluster
  return X[np.random.choice(X.shape[0], n_cluster, replace=False)]

# Hàm xác định tâm cụm.
def kmeans_predict_labels(X, centers):
  D = cdist(X, centers)
## return index of the closest center
  return np.argmin(D, axis = 1)

# Hàm cập nhật lại vị trí của các tâm cụm.
def kmeans_update_centers(X, labels, n_cluster):
  centers = np.zeros((n_cluster, X.shape[1]))
  for k in range(n_cluster):
  ## collect all points assigned to the k-th cluster
    Xk = X[labels == k, :]
  ## take average
    centers[k,:] = np.mean(Xk, axis = 0)
  return centers

# Hàm Kiểm tra tính hội tụ.
def kmeans_has_converged(centers, new_centers):
## return True if two sets of centers are the same
  return (set([tuple(a) for a in centers]) == set([tuple(a) for a in new_centers]))

# Hàm vẽ lên đồ thị để kết quả để quan sát.
## Hàm này dùng để vẽ dữ liệu lên đồ thị
## Random color chỉ làm việc với k &lt;= 4
## Nếu bạn thay đổi k &gt; 4, hãy sửa lại phần random color nhé
## Chỉ sử dụng trong bài toán này thôi nhé.
def kmeans_visualize(X, centers, labels, n_cluster, title):
  plt.xlabel('x') # label trục x
  plt.ylabel('y') # label trục y
  plt.title(title) # title của đồ thị
  plt_colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w'] # danh sách các màu hỗ trợ
  for i in range(n_cluster):
    data = X[labels == i] # lấy dữ liệu của cụm i
    plt.plot(data[:, 0], data[:, 1], plt_colors[i] + '^', markersize=4, label='cluster_' + str(i)) # Vẽ cụm i lên đồ thị
    plt.plot(centers[i][0], centers[i][1], plt_colors[i + 4] + 'o', markersize=10, label='center_' + str(i)) # Vẽ tâm cụm i lên đồ thị
  plt.legend() # Hiện bảng chú thích
  plt.show()
# Toàn bộ thuật toán k-means
def kmeans(init_centes, init_labels, X, n_cluster):
  centers = init_centes
  labels = init_labels
  times = 0
  while True:
    labels = kmeans_predict_labels(X, centers)
    kmeans_visualize(X, centers, labels, n_cluster, 'Assigned label for data at time = ' + str(times + 1))
    new_centers = kmeans_update_centers(X, labels, n_cluster)
    if kmeans_has_converged(centers, new_centers):
      break
    centers = new_centers
    kmeans_visualize(X, centers, labels, n_cluster, 'Update center possition at time = ' + str(times + 1))
    times += 1
  return (centers, labels, times)
# gọi hàm kmeans phía trên để thực thi.
init_centers = kmeans_init_centers(X, n_cluster)
print(init_centers) # In ra tọa độ khởi tạo ban đầu của các tâm cụm
init_labels = np.zeros(X.shape[0])
kmeans_visualize(X, init_centers, init_labels, n_cluster, 'Init centers in the first run. Assigned all data as cluster')
centers, labels, times = kmeans(init_centers, init_labels, X, n_cluster)
print('Done! Kmeans has converged after', times, 'times')
print(centers)

# =============================================================================
# BƯỚC 1: NHẬP THƯ VIỆN (GIỮ NGUYÊN TÊN THƯ VIỆN)
# =============================================================================
import numpy as np
import matplotlib.pyplot as plt # Công cụ vẽ hình
from sklearn.datasets import make_blobs # Công cụ tạo dữ liệu giả
from sklearn.neighbors import KNeighborsClassifier # Thuật toán KNN có sẵn
from sklearn.model_selection import train_test_split # Công cụ chia bài (Học/Thi)
from sklearn.model_selection import GridSearchCV # Công cụ tự tìm cách giải tốt nhất

# =============================================================================
# BƯỚC 2: TẠO DỮ LIỆU GIẢ LẬP
# =============================================================================
print("--- Đang tạo dữ liệu giả lập ---")

# Tạo 100 điểm dữ liệu (100 bệnh nhân), chia làm 4 nhóm bệnh (centers=4)
# Du_lieu_Toa_do (X): Chứa tọa độ x, y (ví dụ: huyết áp, nhịp tim)
# Nhan_Loai_Benh (y): Chứa đáp án (ví dụ: 0=Khỏe, 1=Bệnh A, 2=Bệnh B...)
Du_lieu_Toa_do, Nhan_Loai_Benh = make_blobs(n_samples=100, n_features=2, centers=4,
                                            cluster_std=1, random_state=4)

# =============================================================================
# BƯỚC 3: VẼ HÌNH DỮ LIỆU GỐC
# =============================================================================
print("--- Vẽ biểu đồ phân bố gốc ---")
plt.figure(figsize=(9, 6))
# Vẽ các chấm tròn lên bản đồ
plt.scatter(Du_lieu_Toa_do[:, 0], Du_lieu_Toa_do[:, 1], c=Nhan_Loai_Benh, marker='o', s=50, cmap='viridis')
plt.title("Bản đồ 100 điểm dữ liệu ban đầu")
plt.show()

# =============================================================================
# BƯỚC 4: CHIA DỮ LIỆU ĐỂ HỌC VÀ THI
# =============================================================================
# Chia làm 2 phần:
# - 75% để máy học (Sách giáo khoa)
# - 25% để máy thi (Đề thi)
Du_lieu_Hoc, Du_lieu_Thi, Dap_an_Hoc, Dap_an_Thi = train_test_split(Du_lieu_Toa_do, Nhan_Loai_Benh,
                                                                    test_size=0.25, random_state=0)

print("--- Vẽ biểu đồ đề thi (Dữ liệu máy cần đoán) ---")
plt.figure(figsize=(9, 6))
plt.scatter(Du_lieu_Thi[:, 0], Du_lieu_Thi[:, 1], c=Dap_an_Thi, marker='o', s=50, cmap='viridis')
plt.title("Dữ liệu dùng để thi (Đáp án đúng thực tế)")
plt.show()

# =============================================================================
# BƯỚC 5: MÁY HỌC VÀ ĐOÁN VỚI k=5 (5 HÀNG XÓM)
# =============================================================================
print("--- Máy bắt đầu đoán với k=5 ---")
# Khởi tạo não bộ cho máy, bảo nó hãy nhìn 5 người gần nhất
Mo_hinh_5_Hang_xom = KNeighborsClassifier(n_neighbors=5)

# Cho máy học thuộc lòng dữ liệu
Mo_hinh_5_Hang_xom.fit(Du_lieu_Hoc, Dap_an_Hoc)

# Máy làm bài thi (Dự đoán)
Ket_qua_May_Doan_5 = Mo_hinh_5_Hang_xom.predict(Du_lieu_Thi)

plt.figure(figsize=(9, 6))
plt.scatter(Du_lieu_Thi[:, 0], Du_lieu_Thi[:, 1], c=Ket_qua_May_Doan_5, marker='o', s=50, cmap='viridis')
plt.title("Kết quả máy đoán khi hỏi 5 hàng xóm")
plt.show()

# =============================================================================
# BƯỚC 6: MÁY HỌC VÀ ĐOÁN VỚI k=1 (1 HÀNG XÓM)
# =============================================================================
print("--- Máy bắt đầu đoán với k=1 ---")
Mo_hinh_1_Hang_xom = KNeighborsClassifier(n_neighbors=1) # Chỉ tin 1 người gần nhất
Mo_hinh_1_Hang_xom.fit(Du_lieu_Hoc, Dap_an_Hoc)
Ket_qua_May_Doan_1 = Mo_hinh_1_Hang_xom.predict(Du_lieu_Thi)

plt.figure(figsize=(9, 6))
plt.scatter(Du_lieu_Thi[:, 0], Du_lieu_Thi[:, 1], c=Ket_qua_May_Doan_1, marker='o', s=50, cmap='viridis')
plt.title("Kết quả máy đoán khi hỏi 1 hàng xóm")
plt.show()

# =============================================================================
# BƯỚC 7: TỰ ĐỘNG TÌM SỐ HÀNG XÓM (k) TỐT NHẤT
# =============================================================================
print("--- Máy tự đi tìm xem hỏi bao nhiêu hàng xóm là tốt nhất ---")
# Tạo danh sách số k muốn thử: từ 1 đến 9
danh_sach_k_muon_thu = {'n_neighbors': np.arange(1, 10)}

# Khởi tạo công cụ tìm kiếm
Cong_cu_Tim_kiem = GridSearchCV(estimator=KNeighborsClassifier(),
                                param_grid=danh_sach_k_muon_thu,
                                cv=5)

Cong_cu_Tim_kiem.fit(Du_lieu_Toa_do, Nhan_Loai_Benh)

print(f"--> Máy bảo là: Hỏi {Cong_cu_Tim_kiem.best_params_['n_neighbors']} hàng xóm là chuẩn nhất!")
print("-" * 50)

# =============================================================================
# PHẦN CUỐI: TỰ VIẾT LẠI THUẬT TOÁN (KHÔNG DÙNG THƯ VIỆN)
# =============================================================================
print("\n--- Chạy hàm KNN Tự Viết (Để hiểu bản chất) ---")

def Ham_KNN_Tu_Lam(Tap_Du_lieu_Mau, Tap_Can_Doan, Nhan_cua_Mau, so_hang_xom_k):
    """
    Hàm này mô phỏng lại cách máy tính suy nghĩ
    """
    so_luong_can_doan = Tap_Can_Doan.shape[0]   # Có bao nhiêu điểm cần đoán?
    so_luong_mau = Tap_Du_lieu_Mau.shape[0]     # Trong kho có bao nhiêu mẫu?

    # Tạo bảng trống để ghi chép khoảng cách
    bang_khoang_cach = np.zeros((so_luong_can_doan, so_luong_mau))

    # 1. CẦM THƯỚC ĐI ĐO KHOẢNG CÁCH
    for i in range(so_luong_can_doan):
        for j in range(so_luong_mau):
            # Công thức Pytago: Căn bậc 2 của (Hiệu bình phương tọa độ)
            khoang_cach = np.sqrt(np.sum(np.power(Tap_Can_Doan[i, :] - Tap_Du_lieu_Mau[j, :], 2)))
            bang_khoang_cach[i, j] = khoang_cach

    danh_sach_ket_qua = []

    # 2. XẾP HẠNG VÀ BẦU CỬ
    for i in range(len(bang_khoang_cach)):
        # Ghép khoảng cách vừa đo với đáp án tương ứng
        danh_sach_khoang_cach = zip(bang_khoang_cach[i, :], Nhan_cua_Mau)

        # Sắp xếp: Ai gần nhất (khoảng cách nhỏ nhất) thì đứng đầu
        danh_sach_sap_xep = sorted(danh_sach_khoang_cach, key=lambda x: x[0])

        # Lấy ra top k người đứng đầu
        top_k_nguoi_gan_nhat = danh_sach_sap_xep[:so_hang_xom_k]

        # Kiểm phiếu: Phe nào đông nhất?
        thung_phieu = {}
        for _, nhan_phe in top_k_nguoi_gan_nhat:
            nhan_phe = int(nhan_phe)
            if nhan_phe not in thung_phieu:
                thung_phieu[nhan_phe] = 1
            else:
                thung_phieu[nhan_phe] = thung_phieu[nhan_phe] + 1

        # Tuyên bố phe chiến thắng
        phe_thang_cu = max(thung_phieu, key=thung_phieu.get)
        danh_sach_ket_qua.append(phe_thang_cu)

    return np.array(danh_sach_ket_qua)

# --- THỬ NGHIỆM TRÊN DỮ LIỆU MỚI ---

# Tạo lại dữ liệu mới 500 điểm
(Du_lieu_Moi, Nhan_Moi) = make_blobs(n_samples=500, n_features=2, centers=4,
                                     cluster_std=1, random_state=4)

# Tạo 1 điểm bất kỳ để thử: Tọa độ x=1, y=3
Diem_Can_Doan = np.array([(1, 3)])

# Gọi hàm tự viết
Ket_qua_Cuoi_Cung = Ham_KNN_Tu_Lam(Du_lieu_Moi, Diem_Can_Doan, Nhan_Moi, so_hang_xom_k=3)

print(f"Kết quả dự đoán cho điểm (1, 3): Thuộc nhóm {Ket_qua_Cuoi_Cung[0]}")

# Vẽ hình minh họa
plt.figure(figsize=(9, 6))
plt.scatter(Du_lieu_Moi[:, 0], Du_lieu_Moi[:, 1], c=Nhan_Moi, s=20, alpha=0.3, cmap='viridis', label='Dữ liệu mẫu')
plt.scatter(Diem_Can_Doan[:, 0], Diem_Can_Doan[:, 1], c='red', s=300, marker='*', label='Điểm cần đoán (1,3)')
plt.legend()
plt.title(f"Minh họa: Điểm (1,3) được máy đoán thuộc nhóm {Ket_qua_Cuoi_Cung[0]}")
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from sklearn.neighbors import NearestNeighbors

# ==========================================
# 1. TẠO DỮ LIỆU GIẢ LẬP (TÁO VÀ LÊ)
# ==========================================

# Đặc trưng: [Độ Ngọt (1-10), Độ Giòn (1-10)]
# Nhóm Táo (Đỏ): Ngọt cao (7-9), Giòn cao (7-9)
tao = np.array([
    [8, 9], [7, 8], [8, 8], [9, 9], [7, 9], [9, 8]
])

# Nhóm Lê (Xanh): Ngọt cao (7-9), Giòn thấp (2-4)
le = np.array([
    [8, 3], [7, 4], [9, 2], [7, 3], [8, 2], [9, 4]
])

# Gộp lại thành tập dữ liệu huấn luyện
X_train = np.vstack((tao, le))
y_train = np.array(['Táo'] * len(tao) + ['Lê'] * len(le))

# ==========================================
# 2. TẠO 1 QUẢ BẤT KỲ CẦN DỰ ĐOÁN
# ==========================================
# Quả này có: Độ ngọt = 7.5, Độ giòn = 6
# (Nó nằm lơ lửng ở giữa, hơi khó đoán bằng mắt thường)
qua_bi_an = np.array([[7.5, 6]])

# ==========================================
# 3. CHẠY THUẬT TOÁN KNN (TÌM HÀNG XÓM)
# ==========================================
k = 3 # Chọn 3 hàng xóm gần nhất
model = NearestNeighbors(n_neighbors=k)
model.fit(X_train)

# Tìm khoảng cách và vị trí của k hàng xóm gần nhất
khoang_cach, vi_tri = model.kneighbors(qua_bi_an)

# ==========================================
# 4. VẼ BIỂU ĐỒ TRỰC QUAN HÓA (QUAN TRỌNG NHẤT)
# ==========================================
plt.figure(figsize=(10, 8))

# Vẽ nhóm Táo
plt.scatter(tao[:, 0], tao[:, 1], c='red', s=150, label='Táo (Ngọt & Giòn)')
# Vẽ nhóm Lê
plt.scatter(le[:, 0], le[:, 1], c='green', s=150, label='Lê (Ngọt & Mềm)')
# Vẽ Quả bí ẩn
plt.scatter(qua_bi_an[:, 0], qua_bi_an[:, 1], c='orange', marker='*', s=500, edgecolors='black', label='QUẢ CẦN ĐOÁN')

# VẼ ĐƯỜNG NỐI ĐẾN CÁC HÀNG XÓM (Để giải thích cho thầy)
# Lấy ra danh sách hàng xóm gần nhất
hang_xom_gan_nhat = X_train[vi_tri[0]]

print(f"--- KẾT QUẢ VỚI k={k} ---")
dem_tao = 0
dem_le = 0

for i, hang_xom in enumerate(hang_xom_gan_nhat):
    # Vẽ đường nối
    plt.plot([qua_bi_an[0, 0], hang_xom[0]], [qua_bi_an[0, 1], hang_xom[1]],
             'k--', linewidth=1.5) # Đường nét đứt màu đen

    # Xác định xem hàng xóm đó là Táo hay Lê để in ra
    loai_hang_xom = y_train[vi_tri[0][i]]
    print(f"Hàng xóm thứ {i+1} là: {loai_hang_xom} (Khoảng cách: {khoang_cach[0][i]:.2f})")

    if loai_hang_xom == 'Táo': dem_tao += 1
    else: dem_le += 1

# Kết luận cuối cùng
ket_luan = "TÁO" if dem_tao > dem_le else "LÊ"
print(f"\n==> KẾT LUẬN: Vì có {dem_tao} Táo và {dem_le} Lê ở gần nhất, nên máy đoán đây là quả {ket_luan}!")

# Trang trí biểu đồ
plt.title(f'Demo KNN Phân loại Trái cây (k={k})\nKết quả dự đoán: {ket_luan}', fontsize=15)
plt.xlabel('Độ Ngọt (Thang điểm 10)', fontsize=12)
plt.ylabel('Độ Giòn (Thang điểm 10)', fontsize=12)
plt.legend()
plt.grid(True, linestyle='--', alpha=0.5)
plt.xlim(6, 10)
plt.ylim(1, 10)

plt.show()